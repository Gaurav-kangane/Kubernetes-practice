Deployment strategy in Kubernetes
    1. Recreate 
    2. Rolling Update
    3. Blue Green Deployment
    4. Cannary Deployment


1. Recreate = 
    Recreate is the simplest deployment strategy in Kubernetes.
    Kubernetes terminates all existing pods first, then starts new pods with the updated version.

*** How it works step by step

   1. Old application pods are deleted
    
   2. Application becomes temporarily unavailable
    
   3. New pods are created with the new image or config
    
   4. Traffic resumes once pods are ready


**** Pros and Cons
Pros
   1. Simple and predictable
   2. No version conflicts
   3. Clean startup

Cons
    1. Application downtime
    2. Not fault tolerant during deployment

## recreate.yml

apiVersion: apps/v1
kind: Deployment
metadata:
  name: my-app
spec:
  replicas: 3
  strategy:
    type: Recreate
  template:
    metadata:
      labels:
        app: my-app
    spec:
      containers:
      - name: app
        image: myapp:v2



Practicle = 
1. Create EKS and in compute option create nodegroup
2. Create EC2 server for connecting to nodegroup
3. Install kubernetes in ec2 server and then aws configure keys
4. aws eks update-kubeconfig --region us-east-1 --name <cluster_name>
5. write recreate.yml file and apply it --> kubectl apply -f recreate.yml
6. kubectl get pods --> you will see running pods 
7. Do some changes in recreate.yml file --> change image of yml file and apply it
8. kubectl get pods --> You will see all old pods deleted and the new pods created at same timing


*************************************************************************************************************************************




2. Rolling Update = 
        Rolling Update is the default and most commonly used deployment strategy in Kubernetes.
        It updates your application gradually, replacing old pods with new ones while keeping the app available.
        No full shutdown. Users usually see no downtime.

***How it works step by step =

        Kubernetes creates a new pod with the updated version
        Waits until the new pod is Ready
        Terminates one old pod
        Repeats until all pods are updated
        Old and new versions run together for a short time.


**Pros and Cons

Pros
    Near zero downtime
    Safe for production    
    Built into Kubernetes    
    Easy rollback

Cons
    Old and new versions coexist briefly
    Not ideal if versions are incompatible

***************
Rolling.yml

apiVersion: apps/v1
kind: Deployment
metadata:
  name: web-app
spec:
  replicas: 4
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxSurge: 1
      maxUnavailable: 1
  template:
    metadata:
      labels:
        app: web-app
    spec:
      containers:
      - name: web
        image: web:v2


Practicle=
1. Create rolling.yml file and run it --> kubectl apply -f rolling.yml
2. In yml file maxsurge is 25% and maxUnavailable is 25% the if you make changes in image 
3. 25% of pods will create out of 100% and delete old 25% pods ie.(if running pods are 100 in which 25 pods will create with updated version and old pods
   will be deleted then again 25 new create and 25 old delete this process contineous till 100 new pods will create.)
4. kubectl get pods


*************************************************************************************************************************************************



3. Blue Green Strategy = 

        Blue Green is a deployment strategy where you run two complete versions of your application at the same time.
        
        Blue = current production version
        
        Green = new version
        
        Only one version receives live traffic at a time.

**How it works step by step

        1.Blue version is serving users
        2.Green version is deployed separately
        3.Green is tested internally
        4.Traffic is switched from Blue to Green
        5.Blue is kept for quick rollback
        6.The traffic switch is usually instant.


***Pros and Cons

Pros
    Zero downtime
    
    Instant rollback
    
    No version overlap for users

Cons
    Double infrastructure cost
    
    Manual or scripted traffic switch
    
    Needs good monitoring

    If new application having bug that will impact to end users.


Practicle = 
1. There are 3 file blue.yml green.yml and service.yml
2. In blue.yml we have v1 application code i.e old application run that file --> kubectl apply -f blue.yml
3. Then write service.yml file --> kubectl apply service.yml
4. In service file we set replica as blue then all traffic will redirect to blue application.
5. Write the green.yml file --> kubectl apply -f green.yml
6. In this step both application are running but we configured service file to blue application
7. Run this command --> kubectl get svc --> kubectl describe svc <svc_name> --> note the NodePort port number 
8. Then run command --> kubectl get pods -o wide --> you will see ec2.internal ip see that ip to take public ip of that internal ip and check the application http://35.173.35.171:31951
9. If you want to move your all traffic to green app then do modifications in service.yml file
10.Change replica from blue to green and apply changes --> kubectl apply -f service.yml
11.Refresh the site you will see the new application on browser.



***************************************************************************************************************************************************************************



4. Canary Strategy =
        A canary deployment is a progressive rollout of an application that splits traffic between an already-deployed version and a new version, 
        rolling it out to a subset of users before rolling out fully.

*** How it works step by step
        1. Stable version serves most users
        2. Canary version is deployed with fewer pods
        3. Small traffic percentage goes to Canary
        4. Metrics and logs are monitored
        5. Traffic is increased or rollout is stopped


**Pros and Cons

Pros
    1. Very low risk rollout
    2. Real user testing
    3. Easy rollback
    4. Ideal for production

Cons
    1. More setup needed
    2. Requires monitoring and traffic control
    3. Slower than rolling update


Practicle =

1. In this canary strategy we have 3 files canary-v1.yml canary-v2.yml and service.yml
2. In v1 and v2 replica count is 1 and labels are also same 
3. Run all file --> kubectl apply -f canary-v1.yml, kubectl apply -f canary-v2.yml and kubectl apply -f service.yml
4. Run command --> kubectl get svc --> take load balancer url and paste in the browser
5. Chceck same link in second browser you will see one browser accessing nginx and another is httpd.
6. In this way traffic is distributed to two applications.
7. If there is no bug in your new application increase replica count in new application and reduce replica count in old application.
8. Slowly you can increase replica count in new application and 0 count in old application.
9. In this way without downtime you can do update in application.


